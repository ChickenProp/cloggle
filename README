OVERVIEW

cloggle provides a Clojure interface to OpenGL through JOGL. Currently it is
very thin, and only the GL interface is implemented; there is no support for
GLAutoDrawable or the like.

A GL object can be interfaced with using the with-context macro, which
initialises a context for all calls to opengl functions which occur within its
body. This is a dynamic context, so it will be in effect for functions called
from within the body of with-context. The current context object can be
accessed through the variable *opengl-context*.

Within a context, functions and fields defined by opengl are exposed in the
obvious manner: GL_FIELD_NAMES are downcased with dashes as in gl-field-names,
glFuncNames are downcased with dashes (removing gl) as in (func-names ...).
Functions operate only on the current context object; there is no way to pass
a different one. But you can make a new call to with-context, or just use the
java interop to the JOGL API directly.

cloggle also provides the with-primitive macro, which wraps its body between
calls to glBegin and glEnd.

Illustrative example (not working code):
    (use 'net.philh.cloggle)
    (def gl-obj (get-gl-object-somehow))
    (with-context gl-obj
      (matrix-mode gl-projection)
      (ortho 0 300 0 300 1 128)
      (matrix-mode gl-modelview)
      (translated 0 0 -10)

      (clear gl-depth-buffer-bit)
      (clear gl-color-buffer-bit)
      (with-primitive gl-triangles
        (vertex3d 30 0 0)
        (vertex3d 0 30 0)
        (vertex3d 0 0 0)))

TYPECASTING

int, float, ratio and double types are handled intelligently: functions which
expect one can take any of the others. (ratio is native to clojure, so no
functions expect that, but it can still be passed.) short and byte are not
handled; there seems little point, and clojure doesn't supply short-array or
byte-array functions. You can still call those functions if you like, but you
must specifically pass shorts or bytes to them.

Likewise, functions which expect an array of ints, floats or doubles can accept
an array of any type, or any Seqable clojure type. (Provided in both cases that
all the elements can be cast appropriately; Maps, for instance, don't work.)

These calls will all have the same effect:

    (vertex2i  5 10)
    (vertex2iv (int-array [5 10] 0))
    (vertex2i  5.5 10.7)
    (vertex2iv (float-array [5.5 10.7] 0))
    (vertex2iv [5 10] 0)
    (vertex2iv '(5.5 10.7) 0)

(Note that JOGL functions expecting an array typically also take an offset
argument for the first element to use, so another equivalent call would be
(vertex2iv [3 5 10] 1).

EXPORTS

The following symbols are provided, in addition to the standard gl* functions
and GL_* variables:

(with-context context body...)
Macro. Bindings *opengl-context* to context within body. Also wraps body in
io! (so don't try to use it inside a transaction).

(with-primitive mode body...)
Macro. Wraps body in calls to (glBegin mode) and (glEnd).

(texture-from-file file)
Function. Loads an image from file and returns a 2d RGBA texture representing
it.

(vertex points...)
(color values...)
Functions. Call the appropriate glFunction according to the provided arguments.
Accept sequences as well as individual arguments, so (vertex [1 2]) and
(vertex 1 2) are equivalent. vertex takes 2-4 arguments/seq indices, and color
takes 3-4.

BUGS

Currently unknown.

FUTURE PLANS

* Fix bugs.
* Rename fields: gl-depth-buffer-bit -> depth-buffer-bit? (Would cause name
  collisions.)
* When the 'same' function goes by multiple names, make it available under a
  catch-all (like with vertex, but for more of them).
* Add support for related interfaces, like GLAutoDrawable, GLEventListener and
  GLU.
* Should vertex only accept up to 3 arguments? I don't know if there's any
  reason to ever call vertex4*, and it might screw things up if someone had
  a longer sequence than they expected.
